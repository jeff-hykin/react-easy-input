// Generated by CoffeeScript 2.3.1
var HandleChange, Invalid, React, converters, dependencies, isInvalid, retrieveKeyValueNoExceptions;

React = require("react");

dependencies = require("./converters");

// re-exports
converters = dependencies.converters;

module.exports.converters = converters;

Invalid = dependencies.Invalid;

module.exports.Invalid = Invalid;

isInvalid = dependencies.isInvalid;

module.exports.isInvalid = isInvalid;

HandleChange = (thisFromComponent, stateAttribute, inputer = null) => {
  return (event) => {
    var copyOfState, newValue;
    copyOfState = Object.assign(thisFromComponent.state);
    // create a copy of state instead of mutating the original
    newValue = event.target.value;
    // if there is a converter function, then run the function before it returns to state
    // for example convert "True" into the boolean: true, or convert the string "Jan 12 2017" to dateTime(1,12,2017)
    if (inputer) {
      newValue = inputer(newValue);
    }
    eval("copyOfState." + stateAttribute + " = newValue");
    // if the Attribute is not nested
    // update the compoenent state once with the new state
    return thisFromComponent.setState(copyOfState);
  };
};

retrieveKeyValueNoExceptions = function(object, nested_element, fail_value = "") {
  var output;
  output = fail_value;
  try {
    output = eval("object" + nested_element);
  } catch (error) {}
  return output;
};

module.exports.Input = function(props) {
  var classAdd, className, converter, each, expectedProps, i, inputer, len, linkTo, otherProps, outputer, ref, valueFromState;
  // extract values from props
  expectedProps = [];
  expectedProps.push("linkTo");
  if (props.linkTo) {
    linkTo = props.linkTo;
  } else {
    linkTo = null;
  }
  expectedProps.push("className");
  if (props.className) {
    className = props.className;
  } else {
    className = "easy-input";
  }
  expectedProps.push("classAdd");
  if (props.classAdd) {
    classAdd = props.classAdd;
  } else {
    classAdd = "";
  }
  expectedProps.push("inputer");
  if (props.inputer) {
    inputer = props.inputer;
  } else {
    inputer = null;
  }
  expectedProps.push("outputer");
  if (props.outputer) {
    outputer = props.outputer;
  } else {
    outputer = null;
  }
  
  // create a mutable version of props
  otherProps = {};
  ref = Object.keys(props);
  for (i = 0, len = ref.length; i < len; i++) {
    each = ref[i];
    if (!expectedProps.includes(each)) {
      otherProps[each] = props[each];
    }
  }
  
  // Controlled input

  if (otherProps.this && linkTo) {
    
    //   Compute value

    // retrieve converters
    if (converters[otherProps.type]) {
      converter = converters[otherProps.type];
    } else {
      converter = {};
    }
    if (outputer === null) {
      outputer = converter.outputer;
    }
    if (inputer === null) {
      inputer = converter.inputer;
    }
    
    // retrieve the actual value from the component's state
    valueFromState = retrieveKeyValueNoExceptions(otherProps.this.state, "." + linkTo);
    // convert the value if needed
    if (outputer) {
      valueFromState = outputer(valueFromState);
    }
    // always convert null values to "" (otherwise react will complain)
    if (valueFromState === null || valueFromState === void 0) {
      valueFromState = "";
    }
    
    // Calculate error styling/css class

    // add additional classes
    className = className + " " + classAdd;
    // if invalid was set to something (true/false)
    if (typeof otherProps.invalid === 'bool') {
      // if invalid is true
      if (otherProps.invalid === true) {
        // add error class if there is an "invalid" prop
        className = "easy-input-error " + className;
      }
    // if invalid is false, dont add error class
    // if invalid was not set, but the state value is invalid, then add the error class
    } else if (isInvalid(valueFromState)) {
      className = "easy-input-error " + className;
    }
    // FIXME, check for a errorStyle

    //   Attach values to otherProps

    otherProps.className = className;
    if (!otherProps.value) {
      otherProps.value = valueFromState;
    }
    if (!otherProps.onChange) {
      otherProps.onChange = HandleChange(otherProps.this, linkTo, inputer);
    }
    return React.createElement('input', otherProps, null);
  } else {
    
    // Calculate error styling/css class

    // add additional classes

    // uncontrolled input

    className = className + " " + classAdd;
    // if invalid was set to something (true/false)
    if (typeof otherProps.invalid === 'bool') {
      // if invalid is true
      if (otherProps.invalid === true) {
        // add error class if there is an "invalid" prop
        className = "easy-input-error " + className;
      }
    // if invalid is false, dont add error class
    // if invalid was not set, but the value is invalid, then add the error class
    } else if (isInvalid(otherProps.value)) {
      className = "easy-input-error " + classNam;
    }
    if (!otherProps.className) {
      
      //   Attach values to otherProps

      otherProps.className = className;
    }
    return React.createElement('input', otherProps, null);
  }
};
