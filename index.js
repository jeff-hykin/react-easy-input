// Generated by CoffeeScript 2.3.1
var HandleChange, Invalid, React, converterModule, converters, invalidModule, isInvalid, retrieveKeyValueNoExceptions;

React = require("react");

converterModule = require("./converters");

invalidModule = require('./Invalid');

// re-exports
converters = converterModule.converters;

module.exports.converters = converters;

Invalid = invalidModule.Invalid;

module.exports.Invalid = Invalid;

isInvalid = invalidModule.isInvalid;

module.exports.isInvalid = isInvalid;

// helper function
HandleChange = (thisFromComponent, stateAttribute, inputer = null) => {
  return (event) => {
    var copyOfState, newValue;
    copyOfState = Object.assign(thisFromComponent.state);
    // create a copy of state instead of mutating the original
    newValue = event.target.value;
    // if there is a converter function, then run the function before it returns to state
    // for example convert "True" into the boolean: true, or convert the string "Jan 12 2017" to dateTime(1,12,2017)
    if (inputer) {
      newValue = inputer(newValue);
    }
    eval("copyOfState." + stateAttribute + " = newValue");
    // if the Attribute is not nested
    // update the compoenent state once with the new state
    return thisFromComponent.setState(copyOfState);
  };
};

// helper function
retrieveKeyValueNoExceptions = function(object, nested_element, fail_value = "") {
  var output;
  output = fail_value;
  try {
    output = eval("object" + nested_element);
  } catch (error) {}
  return output;
};

// actual main-code
module.exports.Input = function(props) {
  var classAdd, className, converter, displayInvalid, each, expectedProps, i, inputer, invalidStyle, len, linkTo, newProps, outputer, ref, valueFromState;
  // extract values from props
  expectedProps = [];
  expectedProps.push("invalidStyle");
  if (props.invalidStyle) {
    invalidStyle = props.invalidStyle;
  } else {
    invalidStyle = null;
  }
  expectedProps.push("linkTo");
  if (props.linkTo) {
    linkTo = props.linkTo;
  } else {
    linkTo = null;
  }
  expectedProps.push("className");
  if (props.className) {
    className = props.className;
  } else {
    className = "easy-input";
  }
  expectedProps.push("classAdd");
  if (props.classAdd) {
    classAdd = props.classAdd;
  } else {
    classAdd = "";
  }
  expectedProps.push("inputer");
  if (props.inputer) {
    inputer = props.inputer;
  } else {
    inputer = null;
  }
  expectedProps.push("outputer");
  if (props.outputer) {
    outputer = props.outputer;
  } else {
    outputer = null;
  }
  
  // create a mutable version of props
  newProps = {};
  ref = Object.keys(props);
  for (i = 0, len = ref.length; i < len; i++) {
    each = ref[i];
    if (!expectedProps.includes(each)) {
      newProps[each] = props[each];
    }
  }
  
  // if input is linked
  if (newProps.this && linkTo) {
    
    //   Compute value

    // retrieve converters
    if (converters[newProps.type]) {
      converter = converters[newProps.type];
    } else {
      converter = {};
    }
    if (outputer === null) {
      outputer = converter.outputer;
    }
    if (inputer === null) {
      inputer = converter.inputer;
    }
    
    // retrieve the actual value from the component's state
    valueFromState = retrieveKeyValueNoExceptions(newProps.this.state, "." + linkTo);
    // convert the value if needed
    if (outputer) {
      valueFromState = outputer(valueFromState);
    }
    // always convert null values to "" (otherwise react will complain)
    if (valueFromState === null || valueFromState === void 0) {
      valueFromState = "";
    }
    newProps.value = valueFromState;
    
    //   Compute onChange

    if (!newProps.onChange) {
      newProps.onChange = HandleChange(newProps.this, linkTo, inputer);
    }
  }
  
  // Calculate styling/css class

  // add additional classes
  newProps.className = className + " " + classAdd;
  displayInvalid = false;
  // if 'invalid' prop was set to something (true/false)
  if (typeof newProps.invalid === 'bool') {
    // and if 'invalid' is true
    if (newProps.invalid === true) {
      // then display it
      displayInvalid = true;
    }
  // if 'invalid' is false, dont add error class
  // if 'invalid' prop was not set, but the state value is indeed invalid, then displayInvalid
  } else if (isInvalid(value)) {
    // then display it
    displayInvalid = true;
  }
  if (displayInvalid === true) {
    // add the error css class
    className = "easy-input-error " + className;
    // check if there is an invalid style
    if (invalidStyle) {
      // if there is one then attach it
      newProps.style = invalidStyle;
    }
  }
  // return the react input component
  return React.createElement('input', newProps, null);
};
