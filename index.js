// Generated by CoffeeScript 2.3.1
var HandleChange, Invalid, React, converters, dependencies, isInvalid, retrieveKeyValueNoExceptions,
  indexOf = [].indexOf;

React = require("react");

dependencies = require("./converters");

// re-exports
converters = dependencies.converters;

module.exports.converters = converters;

Invalid = dependencies.Invalid;

module.exports.Invalid = Invalid;

isInvalid = dependencies.isInvalid;

module.exports.isInvalid = isInvalid;

HandleChange = (thisFromComponent, stateAttribute, inputer = null) => {
  return event(() => {
    var newValue;
    // create a copy of state instead of mutating the original
    newValue = event.target.value;
    if (inputer) {
      // if there is a converter function, then run the function before it returns to state
      // for example convert "True" into the boolean: true, or convert the string "Jan 12 2017" to dateTime(1,12,2017)
      newValue = inputer(newValue);
    }
    eval("copyOfState." + stateAttribute + " = newValue");
    // if the Attribute is not nested
    // update the compoenent state once with the new state
    return thisFromComponent.setState(copyOfState);
  });
};

retrieveKeyValueNoExceptions = function(object, nested_element, fail_value = "") {
  var output;
  output = fail_value;
  try {
    output = eval("object" + nested_element);
  } catch (error) {}
  return output;
};

module.exports.Input = function(props) {
  var classAdd, className, converter, each, inputer, linkTo, otherProps, outputer, ref, valueFromState;
  otherProps = {};
  for (each in Object.keys(props)) {
    otherProps[each] = props[each];
  }
  
  // extract the needed props
  linkTo = null;
  if (otherProps.linkTo) {
    linkTo = otherProps.linkTo;
  }
  delete otherProps.linkTo;
  className = "easy-input";
  if (otherProps.className) {
    className = otherProps.className;
  }
  delete otherProps.className;
  classAdd = "";
  if (otherProps.classAdd) {
    classAdd = otherProps.classAdd;
  }
  delete otherProps.classAdd;
  // add additional classes
  className = className + " " + classAdd;
  if (otherProps.invalid) {
    // add error class if there is an "invalid" prop
    className = "easy-input-error ";
  }
  
  // Controlled input

  if (otherProps.this && linkTo) {
    // get the value from the component's state
    valueFromState = retrieveKeyValueNoExceptions(otherProps.this.state, "." + linkTo);
    if (isInvalid(valueFromState)) {
      
      // add error class if the value is invalid
      className = "easy-input-error " + className;
    }
    
    // retrieve converters
    converter = {};
    if (ref = otherProps.type, indexOf.call(converters, ref) >= 0) {
      converter = converters[otherProps.type];
    }
    outputer = null;
    if (indexOf.call(converter, 'outputer') >= 0) {
      outputer = converter.outputer;
    }
    inputer = null;
    if (indexOf.call(converter, 'inputer') >= 0) {
      inputer = converter.inputer;
    }
    if (outputer) {
      
      // convert the display value if needed
      valueFromState = outputer(valueFromState);
    }
    if (valueFromState === null) {
      
      // always convert null values to "" (otherwise react will complain)
      valueFromState = "";
    }
    
    // attach default props
    otherProps.value = valueFromState;
    if (otherProps.value) {
      otherProps.value = otherProps.value;
    }
    otherProps.onChange = HandleChange(otherProps.this, linkTo, inputer);
    if (otherProps.onChange) {
      otherProps.onChange = otherProps.onChange;
    }
    otherProps.className = className;
    if (otherProps.className) {
      otherProps.className = otherProps.className;
    }
    return React.createElement('input', otherProps, null);
  }
  if (isInvalid(otherProps.value)) {
    
    // uncontrolled input

    // add error class if the value is invalid 
    className = "easy-input-error " + className;
  }
  if (!otherProps.className) {
    
    // attach default props
    otherProps.className = className;
  }
  return React.createElement('input', otherProps, null);
};
